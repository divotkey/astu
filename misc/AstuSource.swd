// SWORD Script: AST-Utilities, CMAKE
// Copyright 2021 Roman Divotkey. All rights reserved.

// Configuration
astuVersion = "0.11.0";
privateDir = "src";
publicDir = "include";
srcVar = "astu_SOURCES";
coreModules = [
	"Util", "Math", "Graphics",
	"Audio", "ECS", "Input", 
	"Service", "Suite2D", "Ai",
	"FSM",
	"Velox"
	];
sdlModules = ["SuiteSDL"];
jackModules = ["SuiteJack"];

// Emit CMake file
rootDir = GetInputDirectory();
EmitProlog();
EmitCoreFiles();
EmitOptionalFiles("Sdl", sdlModules, "Build the ASTU library with support for SDL2");
EmitOptionalFiles("Jack", jackModules, "Build the ASTU library with support for JACK Audio Connection Kit");
EmitEpilog();

store(0, rootDir + "CMakeLists.txt");

// Functions

function EmitProlog()
{
	§:
	# CMake file for AST-Utilities Version §{astuVersion}
	# Generated §{date()} with SWORD Interpreter §{version()}

	# Define required CMake version
	cmake_minimum_required(VERSION 3.1)

	# Add version information
	project(ASTU VERSION §{astuVersion})

	# Define C++ Standard
	set(CMAKE_CXX_STANDARD 17)

	:§
}

function EmitEpilog()
{
	EmitHeader("Configuration File");
	§:
	# Setup configuration file to promulgate version info, etc.
	# Note: this needs to be done after definition of optional variables.
	configure_file(src/AstUtilsConfig.h.in AstUtilsConfig.h)

	:§

	EmitStaticLibraryTarget("astu");
	EmitSharedLibraryTarget("astuShared");
}

function EmitStaticLibraryTarget(targetName)
{
	EmitHeader("Static Library Target (" + targetName + ")");
	§:
	# Define static library target.
	add_library(§{targetName} ${§{srcVar}})

	:§

	EmitIncludesAndLinkLibraries(targetName);
}

function EmitSharedLibraryTarget(targetName)
{
	EmitHeader("Shared Library Target (" + targetName + ")");
	§:
	# Define shared library target.
	add_library(§{targetName} SHARED ${§{srcVar}})
	IF (WIN32)
		target_compile_definitions(§{targetName} PRIVATE ASTU_EXPORT)       
	ENDIF()

	:§

	EmitIncludesAndLinkLibraries(targetName);
}

function EmitIncludesAndLinkLibraries(targetName)
{
	listName = targetName + "_INCLUDES";

	§:
	# Set include directories for target §{targetName}
	target_include_directories(
			§{targetName} PRIVATE "${PROJECT_BINARY_DIR}"
			§{targetName} PRIVATE "${PROJECT_SOURCE_DIR}/§{privateDir}"
			§{targetName} PUBLIC "${PROJECT_SOURCE_DIR}/§{publicDir}"
		)

	:§

	// This is currently not tested for shared libraries and probably not working.
	§:
	# Add dependencies for SDL
	if(§{GetOptionName("Sdl")})
		IF (WIN32)
			target_link_libraries(§{targetName} $ENV{SDL2_HOME}/lib/x64/SDL2.lib)
			list(APPEND §{listName} §{targetName} PRIVATE $ENV{SDL2_HOME})
			target_include_directories(§{targetName} PRIVATE $ENV{SDL2_HOME})
		ELSEIF(APPLE)
			#list(APPEND §{listName} §{targetName} PRIVATE /Library/Frameworks/SDL2.framework/Headers)
			target_link_libraries(§{targetName} /Library/Frameworks/SDL2.framework/Versions/A/SDL2)
		ELSE()
			target_link_libraries(§{targetName} SDL2)
		ENDIF()
	endif(§{GetOptionName("Sdl")})                 

	:§

	// This is currently not tested for shared libraries and probably not working.
	§:
	# Add dependencies for Jack
	if(§{GetOptionName("Jack")})
		IF (WIN32)
			target_include_directories(§{targetName} PRIVATE $ENV{JACK2_HOME}/include)
			target_link_libraries(§{targetName} $ENV{JACK2_HOME}/lib/libjack64.lib)
		ELSE()
			target_link_libraries(§{targetName} jack)    
		ENDIF()
	endif(§{GetOptionName("Jack")})    
             
	:§
}

/**
 * Emits Core files for AST-Utilities, must be called first.
 */
function EmitCoreFiles()
{
	EmitHeader("ASTU Core Files");

	§:
	set(§{srcVar})
	list(APPEND §{srcVar}

		# Global files
	:§

	EmitFiles(rootDir + privateDir);
	EmitFiles(rootDir + publicDir);
	§:
	:§
	EmitModules(coreModules);

	§:
		)

	:§
}

/**
 * Creates a option variable name for CMAKE.
 *
 * @param option the plain option name
 * @return the full option name
 */
function GetOptionName(option)
{
	return "ASTU_USE_" + upperCase(option);
}

/**
 * Emits optional source files.
 *
 * @param option the option text
 * @param modules the modules required for the optional code
 * @param text the CMAKE help text
 */
function EmitOptionalFiles(option, modules, text)
{
	if (text == undefined) text = "";
	EmitHeader("Optional Support for " + option);
	cmakeOption = GetOptionName(option);
	§:
	OPTION(§{cmakeOption} "§{text}" OFF)
	if(§{cmakeOption})
  	  list(APPEND §{srcVar} 

	:§

	indent(1);
	EmitModules(modules);
	indent(-1);
	§:
      )
	endif(§{cmakeOption})    
             
	:§
}

function EmitModules(modules)
{
	for (i = 0; i < modules.length; ++i) {
		§:
			# Module: §{modules[i]}
		:§
		EmitFiles(rootDir + privateDir + filePathSeparator() + modules[i], true);
		EmitFiles(rootDir + publicDir + filePathSeparator() + modules[i], true);
		§:
		:§
	}
}

/**
 * Emits all matching files within the specified directory.
 * 
 * This function will emit cpp implementation (*.cpp) and header files (*.h)
 * within the specified directory, but remove the root directory witch
 * is stored in the global variable "rootDir".
 */
function EmitFiles(dir, recursively)
{
	if (recursively == undefined)
		recursively = false;

	print "emitting files in " + dir;
	files = listFiles(dir);
	if (files == undefined) {
		print "directory " + dir + " does not exist";
		return;
	}

	// Process files.
	for (i = 0; i < files.length; ++i) {
		// Process files only.
		if (isDir(files[i])) {
			continue;
		}

		// Process files with mathing extenions only.
		if (!EndsWith(files[i], ".cpp") && !EndsWith(files[i], ".h")) {
			continue;
		}

		// Get relative path.
		sourceEntry = ExtractRelativePath(files[i], rootDir);
		sourceEntry = ToUnixPath(sourceEntry);

		// Emit CMake source line
		§:
			§{sourceEntry} 
		:§
	}

	// Process directories recursively.
	if (recursively) {

		for (i = 0; i < files.length; ++i) {
			// Process directories only.
			if (isDir(files[i])) {
				EmitFiles(files[i]);
			}
		}
	}

}

/**
 * Extracts the relative path from a absolute file location.
 *
 * Example
 *
 * - file: c:\User\Marvin\ProjectA\src\main.cpp
 * - root: c:\User\Marvin\ProjectA\
 * - result: src\main.cpp
 *
 * @param file the absolute file location
 * @param root the path to the root directory which will be removed
 * @param the relative path
 */
function ExtractRelativePath(file, root)
{
	// Search position where strings mismatch.
	i = 0;
	while ((i < file.length) && (i < root.length) && (file[i] == root[i])) {
		++i;
	}

	// If no match, return entire path of file.
	if (i == 0) {
		return file;
	}

	// Extract relative path.
	s = "";
	for (; i < file.length; ++i) {
		s += file[i];
	}

	return s;
}

/**
 * Emits a comment header block.
 *
 * @param text	the comment text
 */
function EmitHeader(text)
{
	s1 = "";
	for (i = 0; i < 7 * 7; ++i) {
		s1 += "#";
	}
	s2 = "";
	for (i = 0; i < 7; ++i) {
		s2 += "#";
	}
	s2 += " " + text;

	§:
	§{s1}
	§{s2}
	§{s1}

	:§
}

/**
 * Converts all backslash file path separators to slashes.
 *
 * @param filepath the input file path to convert
 * @return the converted filepath
 */
function ToUnixPath(filepath)
{
	result = "";
	for (i = 0; i < filepath.length; ++i) {
		if (filepath[i] == "\\") {
			result += "/";
		} else {
			result += filepath[i];
		}
	}

	return result;
}

/**
 * Returns whether the specified string ends with a certain character sequence.
 *
 * @param s				the string to test
 * @param ending	the character sequence
 */
function EndsWith(s, ending)
{
	if (s.length < ending.length)
		return false;

	for (i = 0; i < ending.length; ++i) {
		if (s[s.length - 1 - i] !=  ending[ending.length - 1 - i])
			return false;
	}

	return true;
}

/**
 * Queries the root input directory from the user.
 *
 * If the user cancels the directory selection dialog, this
 * function will terminate the script.
 *
 * @return the input directory
 */
function GetInputDirectory()
{
	// See if a input directory has been stored from a 
	// previous script execution.
	inputDir = recall("inputDir");

	// Run the directory selection dialog.
	result = selectOpenDir(inputDir, "Select Root Directory of Source Code");
	if (!result.approved) {
		// User pressed the canceled button.
		exit;
	}

	// Remember selected input directory on next script execution.
	memorize("inputDir", result.file);

	// Return selected directory and add an
	// operating system specific file path separator.
	return result.file + filePathSeparator();
}
