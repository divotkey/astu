// SWORD Script: ASTU-Source Files, CMAKE
// Copyright 2021 Roman Divotkey. All rights reserved.

// Configuration
astuVersion = "0.11.0";
privateDir = "src";
publicDir = "include";
srcVar = "astulib_SOURCES";
coreModules = [
	"Util", "Math", "Graphics",
	"Audio", "ECS", "Input", 
	"Service", "Suite2D", "Ai",
	"Velox"
	];
sdlModules = ["SuiteSDL"];
jackModules = ["SuiteJack"];

// Emit CMake file
rootDir = GetInputDirectory();
EmitProlog();
EmitCoreFiles();
EmitOptionalFiles("Sdl", sdlModules, "Build the ASTU library with support for SDL2");
EmitOptionalFiles("Jack", jackModules, "Build the ASTU library with support for JACK Audio Connection Kit");
EmitEpilog();

// Functions

function EmitProlog()
{
	§:
	# CMake file for AST-Utilities Version §{astuVersion}
	# Generated §{date()} with SWORD Interpreter §{version()}

	# Define required CMake version
	cmake_minimum_required(VERSION 3.1)

	# Define and promulgate project version information
	project(ASTU VERSION §{astuVersion})
	configure_file(src/AstUtilsConfig.h.in AstUtilsConfig.h)

	# Define C++ Standard
	set(CMAKE_CXX_STANDARD 17)

	:§
}

function EmitEpilog()
{
	EmitHeader("Define targets and include directories");

	§:
	# Define static library target.
	add_library(astu ${astulib_SOURCES})

	# Create and initilaize include list variable
	set(astulib_INCLUDES )
	list(APPEND astulib_INCLUDES
		astu PRIVATE "${PROJECT_BINARY_DIR}"
		astu PRIVATE "${PROJECT_SOURCE_DIR}/§{privateDir}"
		astu PUBLIC ${PROJECT_SOURCE_DIR}/§{publicDir})

	:§

	§:
	if(§{GetOptionName("Sdl")})
  	  IF (WIN32)
    	    target_link_libraries(astu $ENV{SDL2_HOME}/lib/x64/SDL2.lib)
      	  list(APPEND astulib_INCLUDES astu PRIVATE $ENV{SDL2_HOME})
    	ELSEIF(APPLE)
      	  #list(APPEND astulib_INCLUDES astu PRIVATE /Library/Frameworks/SDL2.framework/Headers)
        	target_link_libraries(astu /Library/Frameworks/SDL2.framework/Versions/A/SDL2)
    	ELSE()
      	  target_link_libraries(astu SDL2)
    	ENDIF()
	endif(§{GetOptionName("Sdl")})                 

	:§

	§:
	if(§{GetOptionName("Jack")})
  	  IF (WIN32)
    	    target_include_directories(astu PRIVATE $ENV{JACK2_HOME}/include)
      	  target_link_libraries(astu $ENV{JACK2_HOME}/lib/libjack64.lib)
    	ELSE()
      	  target_link_libraries(astu jack)    
    	ENDIF()
	endif(§{GetOptionName("Jack")})    
             
	:§

	§:
	# Set include directories.
	target_include_directories(${astulib_INCLUDES})
	:§
}



/**
 * Emits Core files for AST-Utilities, must be called first.
 */
function EmitCoreFiles()
{
	EmitHeader("ASTU Core Files");

	§:
	set(§{srcVar})
	list(APPEND §{srcVar}

		# Global files
	:§

	EmitFiles(rootDir + privateDir);
	EmitFiles(rootDir + publicDir);
	§:
	:§
	EmitModules(coreModules);

	§:
		)

	:§
}

/**
 * Creates a option variable name for CMAKE.
 *
 * @param option the plain option name
 * @return the full option name
 */
function GetOptionName(option)
{
	return "ASTU_USE_" + upperCase(option);
}

/**
 * Emits optional source files.
 *
 * @param option the option text
 * @param modules the modules required for the optional code
 * @param text the CMAKE help text
 */
function EmitOptionalFiles(option, modules, text)
{
	if (text == undefined) text = "";
	EmitHeader("Optional Support for " + option);
	cmakeOption = GetOptionName(option);
	§:
	OPTION(§{cmakeOption} "§{text}" OFF)
	if(§{cmakeOption})
  	  list(APPEND §{srcVar} 

	:§

	indent(1);
	EmitModules(modules);
	indent(-1);
	§:
      )
	endif(§{cmakeOption})    
             
	:§
}

function EmitModules(modules)
{
	for (i = 0; i < modules.length; ++i) {
		§:
			# Module: §{modules[i]}
		:§
		EmitFiles(rootDir + privateDir + filePathSeparator() + modules[i]);
		EmitFiles(rootDir + publicDir + filePathSeparator() + modules[i]);
		§:
		:§
	}
}

/**
 * Emits all matching files within the specified directory.
 * 
 * This function will emit cpp implementation (*.cpp) and header files (*.h)
 * within the specified directory, but remove the root directory witch
 * is stored in the global variable "rootDir".
 */
function EmitFiles(dir)
{
	files = listFiles(dir);
	if (files == undefined) {
		print "directory " + dir + " does not exist";
		return;
	}

	for (i = 0; i < files.length; ++i) {
		// Process files only.
		if (isDir(files[i])) {
			continue;
		}

		// Process files with mathing extenions only.
		if (!EndsWith(files[i], ".cpp") && !EndsWith(files[i], ".h")) {
			continue;
		}

		// Get relative path.
		sourceEntry = ExtractRelativePath(files[i], rootDir);
		sourceEntry = ToUnixPath(sourceEntry);

		// Emit CMake source line
		§:
			§{sourceEntry} 
		:§
	}

}

/**
 * Extracts the relavite path from a absolute file location.
 *
 * Example
 *
 * - file: c:\User\Marvin\ProjectA\src\main.cpp
 * - root: c:\User\Marvin\ProjectA\
 * - result: src\main.cpp
 *
 * @param file the absolute file location
 * @param root the path to the root directory which will be removed
 * @param the relativ path
 */
function ExtractRelativePath(file, root)
{
	// Search position where strings mismatch.
	i = 0;
	while ((i < file.length) && (i < root.length) && (file[i] == root[i])) {
		++i;
	}

	// If no match, return entire path of file.
	if (i == 0) {
		return file;
	}

	// Extract relative path.
	s = "";
	for (; i < file.length; ++i) {
		s += file[i];
	}

	return s;
}

/**
 * Emits a comment header block.
 *
 * @param text	the comment text
 */
function EmitHeader(text)
{
	s1 = "";
	for (i = 0; i < 7 * 7; ++i) {
		s1 += "#";
	}
	s2 = "";
	for (i = 0; i < 7; ++i) {
		s2 += "#";
	}
	s2 += " " + text;

	§:
	§{s1}
	§{s2}
	§{s1}

	:§
}

/**
 * Converts all backslash file path separators to slashes.
 *
 * @param filepath the input file path to convert
 * @return the converted filepath
 */
function ToUnixPath(filepath)
{
	result = "";
	for (i = 0; i < filepath.length; ++i) {
		if (filepath[i] == "\\") {
			result += "/";
		} else {
			result += filepath[i];
		}
	}

	return result;
}

/**
 * Returns whether the specified string ends with a certain character sequence.
 *
 * @param s				the string to test
 * @param ending	the character sequence
 */
function EndsWith(s, ending)
{
	if (s.length < ending.length)
		return false;

	for (i = 0; i < ending.length; ++i) {
		if (s[s.length - 1 - i] !=  ending[ending.length - 1 - i])
			return false;
	}

	return true;
}

/**
 * Queries the root input directory from the user.
 *
 * If the user cancels the directory selection dialog, this
 * function will terminate the script.
 *
 * @return the input directory
 */
function GetInputDirectory()
{
	// See if a input directory has been stored from a 
	// previous script execution.
	inputDir = recall("inputDir");

	// Run the directory selection dialog.
	result = selectOpenDir(inputDir, "Select Root Directory of Source Code");
	if (!result.approved) {
		// User pressed the canceled button.
		exit;
	}

	// Remember selected input directory on next script execution.
	memorize("inputDir", result.file);

	// Return selected directory and add an
	// operating system specific file path separator.
	return result.file + filePathSeparator();
}
