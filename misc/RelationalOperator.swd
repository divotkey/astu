// Sword-Script: Arithmetic-Operator
// Copyright 2022 Roman Divotkey. All rights reserved.

types = 
	[ "Undefined"
	, "Integer"
	, "Real"
	, "Boolean"
	, "Color3"
	, "Color4"
	, "Vector2"
	, "Vector3"
	, "Matrix3"
	, "Matrix4"
	, "Quaternion"
	, "String"
	, "Other"
	];


EmitHeader();
EmitSwitchStatement();
EmitFooter();

function EmitSwitchStatement() {

	indent(1);
	§:
		switch(GetType()) {
	:§

	for (j = 0; j < types.length; ++j) {
		§:

			case ItemType::§{types[j]}:
		:§

		indent(1);
		§:
			switch(item->GetType()) {
		:§
		for (i = 0; i < types.length; ++i) {
			§:
	
				case ItemType::§{types[i]}:
					break;
			:§
		}

		§:

			default:
      	throw InterpreterError("relational operation between this two types is undefined", lineNumber);
			}
			break;
		:§
		indent(-1);
	}

	§:

		default:
			throw InterpreterError("relational operation between this two types is undefined", lineNumber);

		}	// end of main-switch
	:§
	indent(-1);
}

function EmitHeader() {
	§:
		namespace velox {

	:§

	indent(1);

	§:
    std::shared_ptr<Item>
    Item::ExecuteRelationalOperator(ScriptContext &sc, 
                                    RelationalOperator op, 
                                    std::shared_ptr<Item> item,
                                    unsigned int lineNumber) const
    {
	:§
}

function EmitFooter() {
	§:

		} // end of method
	:§

	indent(-1);
	§:

		} // end of namespace
	:§
}

