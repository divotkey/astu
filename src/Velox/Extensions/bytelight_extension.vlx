// Velox ByteLight Extension Version 1.1.0
// Copyright 2022-2023 Roman Divotkey. All rights reserved.
//
// AST-Utilities
// Copyright 2020-2023 Roman Divotkey. All rights reserved.


/////////////////////////////////////////////////
/////// Rendering
/////////////////////////////////////////////////

instant Rendering {

	function Rendering() {
		this._width = 512;
		this._height = 512;
		this._patterns = [];
		this._filepath = "./";
		this._filename = undefined;
		this._quality = "GOOD";
		this._mode = "V_NORMALIZED";
	}
	
	function filepath(path) {
		_filepath = path;
	}
	
	function filename(name) {
		_filename = name;
	}
	
	function width(w) {
		_width = w;
	}
	
	function weight(h) {
		_height = h;
	}
	
	function size(w, h) {
		_width = w;
		_height = h;
	}
	
	function quality(q) {
		LogDebug("Setting quality to " + q);
		_quality = q;
	}
	
	function mode(m) {
		_mode = m;
	}

	function GetPixelRadius() {
		return 1.0 / _width;
	}
	
	function GetAspectRatio() {
		return real(_width) / _height;
	}
	
	function AddPattern(pattern) {
		_patterns.append(pattern);
	}
	
	function realize() {
		if (_patterns.size() == 0) return;
		
		img = new Image(_width, _height);
		img.Clear(|0, 0, 0, 0|);
		renderer = undefined;
		if (_quality == "FAST" || _quality == 0) {
			renderer = new SimplePatternRenderer(_mode);
		} else {
			renderer = new PatternRenderer(_mode, _quality);
		}

		LogInfo("Rendering image (" + img.GetWidth() + " x " + img.GetHeight() + ")");
		if (_patterns.size() == 1) {
			LogDebug("_patterns.size() == 1");
			renderer.Render(_patterns[0].GetPattern(), img);
		} else {
			union = new UnionPattern();
			for (i = 0; i < _patterns.size(); ++i) {
				union.AddPattern(_patterns[i].GetPattern());
			}
			renderer.Render(union, img);
		}
		
		ShowImage(img);

		if (_filename != undefined) {
			LogInfo("Storing image to " + _filepath + _filename);
			StoreImage(img, _filepath + _filename);
		}
	}
}


/////////////////////////////////////////////////
/////// Union
/////////////////////////////////////////////////

instant Union {

	function Union() {
		this._pattern = new UnionPattern();
	}

	function translate(v, b) {
		if (b == undefined) {
			_pattern.Translate(v);
		} else {
			_pattern.Translate(<v, b>);
		}
	}

	function scale(v, b) {
		if (b == undefined) {
			_pattern.Scale(v);
		} else {
			_pattern.Scale(<v, b>);
		}
	}

	function rotate(phi) {
		_pattern.Rotate(phi);
	}

	function AddPattern(pattern) {
		_pattern.AddPattern(pattern.GetPattern());
	}

	function GetPattern() {
		return _pattern;
	}
	
	function realize() {
		if (parent == undefined) return;
		parent.AddPattern(this);
	}
}


/////////////////////////////////////////////////
/////// Blur
/////////////////////////////////////////////////

instant Blur {

	function Blur() {
		this._pattern = new BlurPattern();
		this._radius = this._pattern.GetRadius();
		this._numSamples = this._pattern.GetNumSamples();
	}

	function radius(r) {
		_radius = r;
	}
	
	function numSamples(n) {
		_numSamples = n;
	}

	function AddPattern(pattern) {
		_pattern.AddPattern(pattern.GetPattern());
	}
	
	function GetPattern() {
		return _pattern;
	}
	
	function realize() {
		if (parent == undefined) return;
		_pattern.SetNumSamples(_numSamples);
		_pattern.SetRadius(_radius);
		parent.AddPattern(this);
	}
}

instant Quadtree {

	function Quadtree() {
		this._pattern = new QuadtreePattern();
	}

	function AddPattern(pattern) {
		_pattern.AddPattern(pattern.GetPattern());
	}
	
	function GetPattern() {
		return _pattern;
	}
	
	function realize() {
		if (parent == undefined) return;
		_pattern.BuildTree();
		parent.AddPattern(this);
	}
}

/////////////////////////////////////////////////
/////// Unicolor
/////////////////////////////////////////////////

instant Unicolor {

	function Unicolor() {
		this._pattern = new UnicolorPattern();
	}
	
	function color(c) {
		_pattern.SetColor(c);
	}

	function GetPattern() {
		return _pattern;
	}	
	
	function realize() {		
		if (parent == undefined) return;
		parent.AddPattern(this);
	}
}


/////////////////////////////////////////////////
/////// Circle
/////////////////////////////////////////////////

instant Circle {

	function Circle() {
		this._pattern = new CirclePattern();
	}
	
	function radius(r) {
        if (r == undefined)
            return _pattern.GetRadius();

		_pattern.SetRadius(r);
	}
	
	function color(c) {
		_pattern.SetPattern(new UnicolorPattern(c));
	}
	
	function translate(v, b) {
		if (b == undefined) {
			_pattern.Translate(v);		
		} else {
			_pattern.Translate(<v, b>);
		}	
	}
	
	function scale(v, b) {
		if (b == undefined) {
			_pattern.Scale(v);		
		} else {
			_pattern.Scale(<v, b>);
		}	
	}
	
	function rotate(phi) {
		_pattern.Rotate(phi);		
	}	
	
	function rotateDeg(phi) {
		_pattern.RotateDeg(phi);		
	}	
	
	function AddPattern(pattern) {
		_pattern.SetPattern(pattern.GetPattern());
	}
	
	function GetPattern() {
		return _pattern;
	}	
	
	function realize() {		
		if (parent == undefined) return;
		parent.AddPattern(this);
	}
}


/////////////////////////////////////////////////
/////// Rectangle
/////////////////////////////////////////////////

instant Rectangle {

	function Rectangle() {
		this._pattern = new RectanglePattern();
	}

	function width(w) {
	    if (w == undefined)
    	    return this._pattern.GetWidth();

        this._pattern.SetWidth(w);
	}

	function height(h) {
	    if (h == undefined)
    	    return _pattern.GetHeight();

    	this._pattern.SetHeight(h);
	}

	function color(c) {
		this._pattern.SetPattern(new UnicolorPattern(c));
	}

	function translate(v, b) {
		if (b == undefined) {
			this._pattern.Translate(v);
		} else {
			this._pattern.Translate(<v, b>);
		}
	}

	function scale(v, b) {
		if (b == undefined) {
			this._pattern.Scale(v);
		} else {
			this._pattern.Scale(<v, b>);
		}
	}

	function rotate(phi) {
		this._pattern.Rotate(phi);
	}

	function rotateDeg(phi) {
		this._pattern.RotateDeg(phi);
	}

	function AddPattern(pattern) {
		this._pattern.SetPattern(pattern.GetPattern());
	}

	function GetPattern() {
		return this._pattern;
	}

	function realize() {
		if (parent == undefined) return;
		parent.AddPattern(this);
	}

}

/////////////////////////////////////////////////
/////// Line
/////////////////////////////////////////////////

instant Line {

	function Line() {
	    this._p1 = <0.0, 0.0>;
	    this._p2 = <1.0, 0.0>;
	    this._width = 0.01;
	    this._pattern = new RectanglePattern();
	    this._subPattern = undefined;
	    this._caps = false;
	}

	function point1(x, y) {
	    if (x == undefined)
	        return this._p1;

        if (y == undefined) {
            this._p1 = x;
        } else {
            this._p1.x = x;
            this._p1.y = y;
        }
	}

	function point2(x, y) {
	    if (x == undefined)
	        return this._p2;

        if (y == undefined) {
            this._p2 = x;
        } else {
            this._p2.x = x;
            this._p2.y = y;
        }
	}

	function caps(b) {
	    if (b == undefined)
	        return this._caps;

	    this._caps = b;
	}

	function width(w) {
	    if (w == undefined)
	        return this._width;

        this._width = w;
	}

	function color(c) {
        this._subPattern = new UnicolorPattern(c);
	}

	function AddPattern(pattern) {
        this._subPattern = pattern.GetPattern();
	}

	function GetPattern() {
		return this._pattern;
	}

	function realize() {
		if (parent == undefined) return;

		v = this._p1 - this._p2;
		lng = v.Length();
		if (lng == 0) {
		    LogWarning("Degenerated line: " + this._p1 + " - " + this._p2);
		    return;
		}

		this._pattern.SetWidth(lng);
		this._pattern.SetHeight(this._width);
		this._pattern.SetPattern(this._subPattern);

		if (this._caps) {
            union = new UnionPattern();

            c = new CirclePattern(this._width / 2.0);
            c.Translate(<-lng / 2, 0>);
            c.SetPattern(this._subPattern);
            union.AddPattern(c);

            c = new CirclePattern(this._width / 2.0);
            c.Translate(<lng / 2, 0>);
            c.SetPattern(this._subPattern);
            union.AddPattern(c);

            union.AddPattern(this._pattern);
            this._pattern = union;
		}
        this._pattern.Translate((this._p1 + this._p2) / 2.0);
        this._pattern.Rotate(-v.Angle(<1.0, 0.0>));

        parent.AddPattern(this);
	}

}
